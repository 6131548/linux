正则表达式
区别：
      通配符是用来匹配文件名（完全匹配）ls ll cp find
      而正则的匹配文件中的字符串（包含匹配）grep awk sed
      正则符号
      *前一个支付匹配0次或者多次 
      . 匹配出了换行符之外任意一个字符
      ^ 匹配行首 如^hello
      $ 匹配行位
      [] 范围或者任意一个字符
      [^] 取反 [^0-9]代表非数字
      \ 转义符
      \{n\} 代表前面的刚好出现n次 如 [0-9]\{4\} 0-9以内的数字出现4次
      \{n,\} 代表前面的出现不小于n次 如 [0-9]\{4,\} 0-9以内的数字不小于4次
      \{n,m\} 代表前面的出现不小于n次，做多M次 如[a-z]\{6,8\}小写字母出现6-8次
      grep "s.*d" test.text表示在S，D之间有任意字符
      grep ".*" test.text 表示匹配所以内容
      
字符串截取命令
cut 字符段提取命令
-d 制定提取的分隔符 -f 制定提取的列
  cut 命令的局限
  
printf
awk
sed
df -h 看磁盘

字符截取命令-printf命令
printf '输出类型输出格式“ 输出内容
格式
\a输出警告声音
\b输出退格键
\f清屏
\n换行
\r回车
\t水平输出退格 和TAB建一样
\v垂直输出退格和 TAB建一样

%ns 字N个符串
%ni N个整数
%m.nf 输出浮点数 %8.2f表示输出8位数，其中2是小数，6是整数
printf “%s” $(cat hello.sh) //输出接受CAT命令的结果

字符截取命令-awk命令、
#awk '条件1{动作1} 条件2{动作2}..' 文件名
awk '{printf $1 "\t" $3 "\n"}' 1.text   //输出打印 1.text第一行,第三行
FS=":"分隔符
df -h|grep vda1 |awk '{print $5}'|cut -d "%" -f 1 //查看磁盘VDA1占用情况
BEGIN
END

字符截取命令-sed命令
替换 删除 新增
sed [选项] '[动作]' 文件名
-n 输出到屏幕
-e 允许对输入数据应用多条SED命令编辑
-i:用SED修改结果直接修改读取数据的文件，而不是屏幕输出

动作
a \追加
c\:行替换
i\:插入
d:删除
p:打印
s:字符串替换 "行范围S/旧字符串/新字符串/g"
sed  '2,3d' 1.text 输出除2,3行的数据

sed '2d hell' 1.text 追加 

